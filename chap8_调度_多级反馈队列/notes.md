## 调度: 多级反馈队列
本章将介绍一种著名的调度方法——多级反馈队列（Multi-level Feedback Queue，MLFQ）。1962年，Corbato首次提出多级反馈队列[C+62]，应用于兼容时分共享系统（CTSS）。Corbato因在CTSS中的贡献和后来在Multics中的贡献，获得了ACM颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。

多级反馈队列需要解决两方面的问题:
- 优化周转时间,较少护航效应
- 优化交互体验,降低响应时间

OS 通过历史经验预测未来,这样就能预测一个程序大概运行多久,从而放入一个合适的队列.

## MLFQ: 基本规则

MLFQ有许多独立的队列,每个队列有着不同的优先级,任何时刻一个工作只能存在在一个队列之中.MLFQ 总是执行优先级高的任务.

对于同一个队列中的任务,它们有用相同的优先级.这样就可以采用轮转调度.

因此,MLFQ调度策略的关键在于如何设置优先级.MLFQ没有为每个工作指定不变的优先情绪而已,而是根据观察到的行为调整它的优先级.

通过这种方式,MLFQ在进程运行过程中学习其行为,从而利用工作的历史来预测它未来的行为.

至此,我们得到了MLFQ的两条基本规则:
- 规则1:如果A的优先级 > B的优先级，运行A(不运行B);
- 规则2:如果A的优先级 = B的优先级，轮转运行A和B.

需要注意的是,一个工作的优先级并不是一成不变的,而是在运行的过程中是动态调整的.

## 尝试 1: 如何改变优先级
有以下规则:
- 规则3：工作进入系统时，放在最高优先级（最上层队列）。
- 规则4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。
- 规则4b：如果工作在其时间片以内主动释放CPU，则优先级不变。

规则 1 到规则 4b,让 MLFQ 有了很不错的表现,能表现出好的交互相应,又能表现出减少护航效应.

但是 MLFQ 也有缺点,它现在没办法解决长工作的饥饿问题.

也可以被某些程序骗过,从而长期占用 CPU.比如进程在时间片用完之前，调用一个I/O操作（比如访问一个无关的文件），从而主动释放CPU。如此便可以保持在高优先级，占用更多的CPU时间。做得好时（比如，每运行99%的时间片时间就主动放弃一次CPU），工作可以几乎独占CPU。

## 尝试 2: 提升优先级

规则 5: 经过时间 S 后, 将系统中所有的工作重新加入最高优先级队列.

这样就不会存在进程被饿死的状况.

但是 S 设置多长呢? 这是巫毒常量(voo-doo constant).似乎只有设置一个合适的值,才能让 MLFQ 好的工作.

## 尝试 3: 更好的计时方式

现在还有一个问题要解决：如何阻止调度程序被愚弄？可以看出，这里的元凶是规则4a和4b，导致工作在时间片以内释放CPU，就保留它的优先级。那么应该怎么做？这里的解决方案，是为MLFQ的每层队列提供更完善的CPU计时方式（accounting）。调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。只要进程用完了自己的配额，就将它降到低一优先级的队列中去。不论它是一次用完的，还是拆成很多次用完。因此，我们重写规则4a和4b。规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。

## MLFQ 调优以及其它问题

## MLFQ 总结
- 规则1：如果A的优先级 > B的优先级，运行A（不运行B）。
- 规则2：如果A的优先级 = B的优先级，轮转运行A和B。
- 规则3：工作进入系统时，放在最高优先级（最上层队列）。
- 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。
- 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。

它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ可以同时满足各种工作的需求：对于短时间运行的交互型工作，获得类似于SJF/STCF的很好的全局性能，同时对长时间运行的CPU密集型负载也可以公平地、不断地稳步向前。因此，许多系统使用某种类型的MLFQ作为自己的基础调度程序，包括类BSD UNIX系统[LM+89，B86]、Solaris[M06]以及Windows NT和其后的Window系列操作系统。



