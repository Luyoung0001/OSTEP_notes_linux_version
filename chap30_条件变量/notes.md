# 条件变量
具体来说，在很多情况下，线程需要检查某一条件（condition）满足之后，才会继续运行.

我们可以尝试用一个共享变量. 这种解决方案一般能工作，但是效率低下，因为主线程会自旋检查，浪费CPU时间。我们希望有某种方式让父线程休眠，直到等待的条件满足（即子线程完成执行）.

## 定义和程序

线程可以使用条件变量（condition variable），来等待一个条件变成真。条件变量是一个显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待（waiting）该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行.


要声明这样的条件变量，只要像这样写：pthread_cond_t c;，这里声明c是一个条件变量（注意：还需要适当的初始化）。条件变量有两种相关操作：wait()和signal()。线程要睡眠的时候，调用wait()。当线程想唤醒等待在某个条件变量上的睡眠线程时，调用signal()。

我们常简称为wait()和signal()。你可能注意到一点，wait()调用有一个参数，它是互斥量。它假定在wait()调用时，这个互斥量是已上锁状态。wait()的职责是释放锁，并让调用线程休眠（原子地）。当线程被唤醒时（在另外某个线程发信号给它后），它必须重新获取锁，再返回调用者。这样复杂的步骤也是为了避免在线程陷入休眠时，产生一些竞态条件。我们观察一下图30.3中join问题的解决方法，以加深理解.

有两种情况需要考虑。第一种情况是父线程创建出子线程，但自己继续运行（假设只有一个处理器），然后马上调用thr_join()等待子线程。在这种情况下，它会先获取锁，检查子进程是否完成（还没有完成），然后调用wait()，让自己休眠。子线程最终得以运行，打印出“child”，并调用thr_exit()函数唤醒父进程，这段代码会在获得锁后设置状态变量done，然后向父线程发信号唤醒它。最后，父线程会运行（从wait()调用返回并持有锁），释放锁，打印出“parent:end”。

第二种情况是，子线程在创建后，立刻运行，设置变量done为1，调用signal函数唤醒其他线程（这里没有其他线程），然后结束。父线程运行后，调用thr_join()时，发现done已经是1了，就直接返回.

```C
1    void thr_exit() {
2        Pthread_mutex_lock(&m);
3        Pthread_cond_signal(&c);
4        Pthread_mutex_unlock(&m);
5    }
6
7    void thr_join() {
8        Pthread_mutex_lock(&m);
9        Pthread_cond_wait(&c, &m);
10       Pthread_mutex_unlock(&m);
11   }
```

这段代码是有问题的。假设子线程立刻运行，并且调用thr_exit()。在这种情况下，子线程发送信号，但此时却没有在条件变量上睡眠等待的线程。父线程运行时，就会调用wait并卡在那里，没有其他线程会唤醒它。通过这个例子，你应该认识到变量done的重要性，它记录了线程有兴趣知道的值。睡眠、唤醒和锁都离不开它。

也就是说,不能在 signal 时,没有线程处于等待状态,不然可能就一直 wait.

## 提示：发信号时总是持有锁

尽管并不是所有情况下都严格需要，但有效且简单的做法，还是在使用条件变量发送信号时持有锁。虽然上面的例子是必须加锁的情况，但也有一些情况可以不加锁，而这可能是你应该避免的。

因此，为了简单，请在调用signal时持有锁（hold the lock when calling signal）。这个提示的反面，即调用wait时持有锁，不只是建议，而是wait的语义强制要求的。因为wait调用总是假设你调用它时已经持有锁、调用者睡眠之前会释放锁以及返回前重新持有锁。因此，这个提示的一般化形式是正确的：调用signal和wait时要持有锁（hold the lock when calling signal or wait）.

但是其实在现实中,没必要遵守这个建议.我时常在释放锁之后,再 signal,从来没遇到过出乎意料的问题.

我认为这样可以防止 signal 之后,线程还没来得及释放锁,让对方空欢喜一场.当然,这种可能性微乎其微.

## 生产者/消费者问题

假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费。

由于Mesa语义，我们要记住一条关于条件变量的简单规则：总是使用while循环（always use while loop）。虽然有时候不需要重新检查条件，但这样做总是安全的，做了就开心了。

信号显然需要，但必须更有指向性。消费者不应该唤醒消费者，而应该只唤醒生产者，反之亦然。

解决方案也很简单：使用两个条件变量，而不是一个，以便正确地发出信号，在系统状态改变时，哪类线程应该唤醒.

## 提示：对条件变量使用while（不是if）

多线程程序在检查条件变量时，使用while循环总是对的。if语句可能会对，这取决于发信号的语义。因此，总是使用while，代码就会符合预期。对条件变量使用while循环，这也解决了假唤醒（spurious wakeup）的情况。某些线程库中，由于实现的细节，有可能出现一个信号唤醒两个线程的情况[L11]。再次检查线程的等待条件，假唤醒是另一个原因。

## 覆盖条件

由于在唤醒某一类线程时,不知道具体应该唤醒哪一个线程,就会通过唤醒这一类所有的线程.

比如:

```C
    // how many bytes of the heap are free?
    int bytesLeft = MAX_HEAP_SIZE;

    // need lock and condition too
    cond_t c;
    mutex_t m;

    void *
    allocate(int size) {
       Pthread_mutex_lock(&m);
       while (bytesLeft < size)
           Pthread_cond_wait(&c, &m);
       void *ptr = ...; // get mem from heap
       bytesLeft -= size;
       Pthread_mutex_unlock(&m);
       return ptr;
   }

   void free(void *ptr, int size) {
       Pthread_mutex_lock(&m);
       bytesLeft += size;
       Pthread_cond_signal(&c); // whom to signal??
       Pthread_mutex_unlock(&m);
   }
```

考虑以下场景。假设目前没有空闲内存，线程Ta调用allocate(100)，接着线程Tb请求较少的内存，调用allocate(10)。Ta和Tb都等待在条件上并睡眠，没有足够的空闲内存来满足它们的请求。这时，假定第三个线程Tc调用了free(50)。

遗憾的是，当它发信号唤醒等待线程时，可能不会唤醒申请10字节的Tb线程。而Ta线程由于内存不够，仍然等待。因为不知道唤醒哪个（或哪些）线程，所以图中代码无法正常工作。

Lampson和Redell的解决方案也很直接：用pthread_cond_broadcast()代替上述代码中的pthread_cond_signal()，唤醒所有的等待线程。这样做，确保了所有应该唤醒的线程都被唤醒。当然，不利的一面是可能会影响性能，因为不必要地唤醒了其他许多等待的线程，它们本来（还）不应该被唤醒。这些线程被唤醒后，重新检查条件，马上再次睡眠。

## 小结

我们看到了引入锁之外的另一个重要同步原语：条件变量。当某些程序状态不符合要求时，通过允许线程进入休眠状态，条件变量使我们能够漂亮地解决许多重要的同步问题，包括著名的（仍然重要的）生产者/消费者问题，以及覆盖条件。



