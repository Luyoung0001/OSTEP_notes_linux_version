## 创建进程
- 操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到进程的地址空间中。

- 将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操作。必须为程序的运行时栈（run-time stack或stack）分配一些内存。

- 操作系统也可能为程序的堆（heap）分配一些内存。在C程序中，堆用于显式请求的动态分配数据。程序通过调用malloc()来请求这样的空间，并通过调用free()来明确地释放它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。起初堆会很小。随着程序运行，通过malloc()库API请求更多内存，操作系统可能会参与分配更多内存给进程，以满足这些调用。

- 操作系统还将执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。例如，在UNIX系统中，默认情况下每个进程都有3个打开的文件描述符（file descriptor），用于标准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。
- 启动程序，在入口处运行，即main()。


## 进程状态
- 运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。
- 就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。
- 阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起I/O请求时，它会被阻塞，因此其他进程可以使用处理器。(因为相比较于 CPU磁盘访问太慢了)


有一些进程处于退出状态,但是没有被清理(进程链表中未剔除出去),这些进程就成了僵尸进程.

一般情况下,一个进程在退出后,需要由父进程来收尸,就是当父进程没有 wait()的时候,子进程就会变成僵尸进程.

僵尸进程无法被 kill 杀死,因为 kill 本质上传递的就是传递一个信号.

当一个进程处于两种情况会忽略所有信号:
- 处于核心态:处于核心态的进程会忽略所有信号
- 处于僵尸态:僵尸进程是死掉的进程,自然不会处理信号.

这就是为什么僵尸进程无法被 kill 杀死.

那么怎么杀死一个僵尸进程呢?

答案就是:当一个僵尸进程的父进程被杀死的时候,该僵尸进程就会被过继给 init 进程,init 进程会托管该僵尸进程,init会负责清理这些僵尸进程
具体可以看看https://blog.csdn.net/m0_73651896/article/details/132725152这篇文章,我在这里写得很详细,不再赘述.

## wait()
wait()一个重要的作用就是等待子进程完成或者给子进程收尸.没人收尸,子进程运行结束后就变成了僵尸进程.

## 重定向
重定向看起来比较神秘,其实实现起来很简单
关键的核心在于:
- 操作系统为每个进程都默认打开 3 个文件描述符:标准输入,标准输出,标准错误
- 当关闭标准输出,再打开某个文件,操作系统就会从最0 开始寻找可用的文件描述符,自然而然,标准输出就成了第一个可用的文件描述符,然后赋值给这个文件.
- 这样标准输出时,就会透明地将信息输出到这个文件里.

比如`text.c`就是一个很好的例子


